# collection

## Overview

This is an Golang implementation example of a Merkle-tree based weighted collection. 

It defines two classes: a `Collection` and a `Verifier`. Keys (namely, `Buffers`, a.k.a. `[]uint8`) can be added to a `Collection` along with a `value`, which will represent a weight of value in the `Collection`.

Each operation on a `Collection` (namely, adding an `(key, value)` couple, verifying the existence of a `key` and fetching its `value`, updating the `value` for a given `key`, removing a `key` and performing a *cumulative fetch* (see later)) returns a `Proof` object that can be verified by a `Verifier`, which will be able to keep track of the updates performed to its corresponding `Collection` by storing its Merkle tree root and successively verifying its updates.

## Hands on

### Basics

Creating an empty collection is as easy as
```Go
mycollection := MakeCollection() // Creates an empty collection
```

Now, `mycollection` has no elements in it, and its corresponding Merkle tree is just a root with two placeholder nodes (see later). The root of the Merkle tree can be accessed by
```Go
emptyroot := mycollection.root.label // This is the label of our currently empty collection
```
(note that the root of an empty collection is always the same, and can be generated on any client)

We can use our newly obtained root to create our `Verifier`, which will verify the `Proof`s generated by `mycollection`:
```Go
myverifier := MakeVerifier(emptyroot) // Creates a verifier on the new empty Merkle root
```

### Adding

We are now ready to add an element to `mycollection`. This can be done by specifying a couple `(key, value)`, where `key` is a `Buffer` (a.k.a. `[]uint8`) and `value` is an `uint64`:
```Go
myproof := mycollection.add(BufferFromString("Matteo"), 17) // Adds "Matteo" with value 17 to the collection

if(myproof.success) {
    fmt.Println("Key successfully added") // It works!
}
```

Note how this yields an object `myproof`. This can be verified by any `Verifier` whose Merkle root is equal to that of `mycollection` before the operation. Let's use `myverifier` to verify the proof:
```Go
if(myverifier.verify(myproof)) {
    fmt.Println("Verification successful") // Yay!
}
```

In general, the two operations (namely, adding a key and verifying the corresponding proof) will be carried out on two separate machines (e.g. a co-node and a ledger client). It will be responsibility of the library user to serialize over the network the `Proof` object (which should be easily doable).

**Remark**: all the cryptographic operations that are carried out are independent of system endianess, which does not need to be taken into account at the user level.

### Other operations

The presence of a `key` in a `Collection` can be verified as follows:
```Go
myproof = mycollection.get(BufferFromString("Matteo"))

if(myproof.success) {
    fmt.Println("Key", myproof.key, "exists in the collection with value", myproof.value) // Actually prints out 17
}

if(myverifier.verify(myproof)) {
    fmt.Println("Verification successful")
}
```

This, for example, can allow a client to query a remote `Collection` (e.g., on a remote co-node) to verify if a given identifier resides in the `Collection`, and what is its value.

**Remark**: note how `myverifier` successfully verified the `Proof` yielded by `mycollection`. This is due to the fact that, when we verified the `add` proof, `myverifier` accordingly updated its internal Merkle tree root, from which the existence of `Matteo` in the `Collection` can be proven.

In a similar way we can update the value of, and delete, our `key` from `mycollection` with:
```Go
myproof = mycollection.update(BufferFromString("Matteo"), 10000) // I'm rich!!
myverifier.verify(myproof)
myproof = mycollection.delete(BufferFromString("Matteo")) // D'oh!
myverifier.verify(myproof)
```

### Cumulative fetch

A *cumulative fetch* on a `Collection` in the form 
```Go
mycollection.cumulative(value)
``` 
yields the largest item in the `Collection` whose value doesn't overflow `value` in the cumulative histogram of the values of the entries in the `Collection`.

Consider, for example, the case of a `Collection` `mycollection` with the following entries / values:

| Key      | Value |
|----------|-------|
| Matteo   | 17    |
| Giovanni | 42    |
| Marco    | 11    |
| Stefano  | 0     |

(the order being determined by their order of appearance in a depth-first exploration of the Merkle tree of `mycollection`)

The total value in the `Collection` is therefore `total = 17 + 42 + 11 + 0 = 70`. We can therefore call `mycollection.cumulative(value)` with `value` in `[0, 69]`. The `cumulative` function will provably compute the cumulative histogram of the values, and pick the last that doesn't overflow `value`.

Following from the example, here is the results corresponding to various ranges of `value`:

| Range    | Keu      |
|----------|----------|
| [0, 16]  | Matteo   |
| [17, 58] | Giovanni |
| [59, 69] | Marco    |
| (never)  | Stefano  |

This feature can be used to pick random elements from a `Collection`, with a probability weighted by the `value` of each key (as we would do, e.g., in a *Proof of Stake* context). It will be sufficient, in fact, to generate a provably random number in the range `[0, total - 1]` and perform a cumulative fetch on the `Collection`.

## Design

### Hashes

A `Hash` function is defined to perform a `SHA256` hash on tuples of `Serializable` elements. When hashing a set of elements, the length in bytes of each element is encoded in an endianess-invariant fashion and prepended to each element of the tuple, and the resulting string is hashed. This prevents forging collisions either by changing the length of the entries in a tuple or by changing the number of entries in a tuple.

### Merkle trees

`Collection`s implement Merkle trees. Let *node* identify a non-*leaf* node in the tree. A Merkle tree will always respect the following properties:

 * A *node* has always two children. 
 * If necessary, one of them can be a *placeholder leaf*, i.e., a leaf with empty `key` and null `value`.
 * No *node* exists with two *placeholder leaves* as children. If such a node is generated after a removal, it is substituted with a *placeholder leaf*.
 * A non-placeholder *leaf* stores a *key* and a *value*.
 * Both *nodes* and *leaves* have a `label`.
 * The `label` of a *leaf* (placeholder or not) is the `Hash` of the boolean value `true`, of the 64-bit encoding of `value`, and of `key`.
 * The `label` of a *node* is the `Hash` of the boolean value `false`, of the 64-bit encoding of `value`, of the label of the left child, and of the label of the right child.
 * The `value` of a *node* is given by the sum of the `value`s of it children.
 * An element with key `key` will appear on the path that starts by the root and that is defined by the binary expansion of `Hash(key)`, `0` meaning *left* and `1` meaning *right*.

### Proofs

Every operation produces a Merkle proof constrained either by the `key` provided to `add`, `get`, `update` and `remove`, or by the `value` provided to `cumulative`. Since the path is uniquely determiend by either of those, `Collection`s can not only prove the existence of a `key`, but also its non-existence.

In particular:
 * The proof of `add` is the Merkle proof up to the first *leaf* along the path determined by `key`. That can be either a placeholder leaf or a non-placeholder leaf. If a placeholder leaf is encountered, it is simply substituted with a non-placeholder leaf storing the tuple `(key, value)`, and the new root of the Merkle tree can be independently re-computed by the `Verifier`.
 If a non-placeholder leaf is encountered, the `Verifier` will be able to verify its `key`, compute its `Hash`, and therefore determine the path along which to *push down* the leaf. The leaf is successively replaced by a node until the collision with `key` is solved. Also in this context, the data provided is sufficient to a `Verifier` to re-compute the root of the Merkle tree.
 * The proof of `get` is simply a Merkle proof of all the nodes along the `path` determined by `Hash(key)` until the first leaf is encountered. If `leaf.key` matches the `key` provided, the query is verifiably successful. Otherwise, it is verifiably unsuccessful.
 * The proof of `update` is identical to that of `get`, except that when the query is successful, the `value` is updated, which means that `Verifier` will re-compute the Merkle-root from the requested update. When updating the value, the `value` of each node along the path to the root is re-computed from its children.
 * The proof of `remove` is similar to that of `update`, except that, when successful, the leaf is replaced with a placeholder leaf. When recurring upwards to re-compute the root of the Merkle tree, every time a node has two placeholder leaves, it is substituted by a placeholder leaf. This allows to keep the tree compact even multiple additions and removals.
 * The proof of `cumulative` is identical to that of `get`, except that the path is not determined by the bit expansion of the `Hash` of a `key`, but by a `value`. When navigating, if `value` is greater or equal to the value of the left child of the node, the `Collection` navigates right and subtracts the value of the left child from `value`. Otherwise, it navigates left and leaves `value` unchanged.
